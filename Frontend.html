<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drop2Me - ‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ö‡∏ö P2P</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        /* Animated Background */
        body::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: moveBackground 20s linear infinite;
        }

        @keyframes moveBackground {
            0% {
                transform: translate(0, 0);
            }

            100% {
                transform: translate(50px, 50px);
            }
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 30px;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.2);
            max-width: 800px;
            width: 100%;
            padding: 50px;
            position: relative;
            z-index: 1;
            animation: slideUp 0.6s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .logo {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            animation: float 3s ease-in-out infinite;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        h1 {
            font-size: 36px;
            font-weight: 800;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #6b7280;
            font-size: 16px;
            font-weight: 400;
        }

        /* Status Badge */
        .status-container {
            text-align: center;
            margin-bottom: 30px;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.3s;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: blink 1.5s ease-in-out infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        .status-waiting {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            color: #92400e;
        }

        .status-waiting .status-dot {
            background: #f59e0b;
        }

        .status-connecting {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            color: #1e40af;
        }

        .status-connecting .status-dot {
            background: #3b82f6;
        }

        .status-connected {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            color: #065f46;
        }

        .status-connected .status-dot {
            background: #10b981;
        }

        .status-transferring {
            background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
            color: #3730a3;
        }

        .status-transferring .status-dot {
            background: #6366f1;
        }

        /* Setup Screen */
        .setup-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .setup-card {
            background: linear-gradient(135deg, #f9fafb 0%, #ffffff 100%);
            border: 2px solid #e5e7eb;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .setup-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .setup-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.2);
            border-color: #667eea;
        }

        .setup-card:hover::before {
            opacity: 0.05;
        }

        .setup-icon {
            font-size: 50px;
            margin-bottom: 15px;
            position: relative;
            z-index: 1;
        }

        .setup-title {
            font-size: 20px;
            font-weight: 700;
            color: #111827;
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
        }

        .setup-desc {
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            z-index: 1;
            width: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }

        .btn-secondary:hover {
            background: #e5e7eb;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Join Room Section */
        .join-section {
            background: linear-gradient(135deg, #f9fafb 0%, #ffffff 100%);
            border: 2px solid #e5e7eb;
            border-radius: 20px;
            padding: 30px;
            margin-top: 20px;
        }

        .join-title {
            font-size: 18px;
            font-weight: 700;
            color: #111827;
            margin-bottom: 15px;
            text-align: center;
        }

        .input-group {
            display: flex;
            gap: 12px;
        }

        input[type="text"] {
            flex: 1;
            padding: 16px 20px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            letter-spacing: 4px;
            text-transform: uppercase;
            transition: all 0.3s;
            font-family: 'Inter', monospace;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }

        /* Transfer Screen */
        .room-banner {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .room-banner::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 30px 30px;
            animation: moveBackground 15s linear infinite;
        }

        .room-label {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
        }

        .room-code {
            font-size: 48px;
            font-weight: 800;
            letter-spacing: 8px;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .room-hint {
            font-size: 14px;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }

        /* File Upload Area */
        .upload-zone {
            background: linear-gradient(135deg, #f9fafb 0%, #ffffff 100%);
            border: 3px dashed #d1d5db;
            border-radius: 20px;
            padding: 60px 40px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .upload-zone:hover {
            border-color: #667eea;
            background: linear-gradient(135deg, #f0f4ff 0%, #ffffff 100%);
            transform: scale(1.02);
        }

        .upload-zone.dragover {
            border-color: #667eea;
            background: linear-gradient(135deg, #e0e7ff 0%, #f0f4ff 100%);
            transform: scale(1.05);
        }

        .upload-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: bounce 2s ease-in-out infinite;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        .upload-title {
            font-size: 22px;
            font-weight: 700;
            color: #111827;
            margin-bottom: 8px;
        }

        .upload-subtitle {
            font-size: 14px;
            color: #6b7280;
        }

        input[type="file"] {
            display: none;
        }

        /* File Info Card */
        .file-card {
            background: linear-gradient(135deg, #f0f4ff 0%, #ffffff 100%);
            border: 2px solid #667eea;
            border-radius: 20px;
            padding: 25px;
            margin-top: 20px;
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .file-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .file-icon-large {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
        }

        .file-details {
            flex: 1;
        }

        .file-name {
            font-size: 18px;
            font-weight: 700;
            color: #111827;
            margin-bottom: 5px;
            word-break: break-word;
        }

        .file-meta {
            display: flex;
            gap: 15px;
            font-size: 14px;
            color: #6b7280;
        }

        .file-meta-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Progress Bar */
        .progress-section {
            margin-top: 30px;
            animation: fadeIn 0.4s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .progress-title {
            font-size: 16px;
            font-weight: 600;
            color: #111827;
        }

        .progress-percentage {
            font-size: 24px;
            font-weight: 800;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .progress-bar-container {
            width: 100%;
            height: 12px;
            background: #e5e7eb;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .progress-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 14px;
            color: #6b7280;
        }

        /* Messages */
        .message {
            padding: 16px 20px;
            border-radius: 12px;
            margin-top: 20px;
            font-size: 15px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideIn 0.3s ease-out;
        }

        .message-success {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            color: #065f46;
            border: 2px solid #10b981;
        }

        .message-error {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            color: #991b1b;
            border: 2px solid #ef4444;
        }

        .message-info {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            color: #1e40af;
            border: 2px solid #3b82f6;
        }

        /* Action Buttons */
        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 30px;
        }

        .btn-full {
            grid-column: 1 / -1;
        }

        /* Utilities */
        .hidden {
            display: none !important;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 30px 20px;
            }

            h1 {
                font-size: 28px;
            }

            .setup-grid {
                grid-template-columns: 1fr;
            }

            .room-code {
                font-size: 36px;
                letter-spacing: 4px;
            }

            .upload-zone {
                padding: 40px 20px;
            }

            .upload-icon {
                font-size: 60px;
            }

            .action-buttons {
                grid-template-columns: 1fr;
            }

            .input-group {
                flex-direction: column;
            }
        }

        .btn-icon {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .btn-icon:hover {
            opacity: 1;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            width: 90%;
            max-width: 400px;
            padding: 25px;
            animation: slideUp 0.3s ease-out;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-header h2 {
            font-size: 20px;
            color: #111827;
            margin: 0;
        }

        .close-modal {
            font-size: 28px;
            cursor: pointer;
            color: #6b7280;
        }

        .setting-group {
            margin-bottom: 15px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #374151;
        }

        .setting-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 16px;
        }

        .modal-footer {
            margin-top: 20px;
            text-align: right;
        }

        /* Loading Animation */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading {
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        /* Security Badge */
        .security-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            margin-top: 10px;
        }

        .security-badge.pending {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        /* Room Timer */
        .room-timer {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            margin-top: 12px;
            font-size: 13px;
            opacity: 0.9;
        }

        .room-timer.warning {
            color: #fbbf24;
        }

        .room-timer.critical {
            color: #ef4444;
            animation: blink 1s ease-in-out infinite;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo">üìÅ</div>
            <h1>Drop2Me</h1>
            <p class="subtitle">‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ö‡∏ö P2P ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á ‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå</p>
            <button class="btn-icon" id="settingsBtn" title="‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤">‚öôÔ∏è</button>
        </div>

        <!-- Settings Modal -->
        <div id="settingsModal" class="modal hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ (Settings)</h2>
                    <span class="close-modal" id="closeSettings">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="setting-group">
                        <label>Bandwidth Limit (‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå)</label>
                        <select id="bandwidthSelect">
                            <option value="0">‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î (Unlimited)</option>
                            <option value="1">1 MB/s</option>
                            <option value="5">5 MB/s</option>
                            <option value="10">10 MB/s</option>
                        </select>
                    </div>
                    <hr>
                    <div class="setting-group">
                        <label>Room TTL (‡∏≠‡∏≤‡∏¢‡∏∏‡∏´‡πâ‡∏≠‡∏á)</label>
                        <select id="ttlSelect">
                            <option value="1440">24 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á (Default)</option>
                            <option value="60">1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á</option>
                            <option value="10">10 ‡∏ô‡∏≤‡∏ó‡∏µ</option>
                            <option value="1">1 ‡∏ô‡∏≤‡∏ó‡∏µ</option>
                        </select>
                    </div>
                    <div class="setting-group">
                        <label>Max Peers (‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏ô)</label>
                        <select id="maxPeersSelect">
                            <option value="0">‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î</option>
                            <option value="2">1 ‡∏Ñ‡∏ô (One-time Access)</option>
                        </select>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-primary" id="saveSettingsBtn">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</button>
                </div>
            </div>
        </div>

        <!-- Status Badge -->
        <div class="status-container">
            <div id="statusBadge" class="status-badge status-waiting">
                <span class="status-dot"></span>
                <span>‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠</span>
            </div>
        </div>

        <!-- Setup Screen -->
        <div id="setupScreen">
            <div class="setup-grid">
                <div class="setup-card" id="createCard">
                    <div class="setup-icon">üöÄ</div>
                    <div class="setup-title">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà</div>
                    <div class="setup-desc">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡πÅ‡∏ä‡∏£‡πå‡∏£‡∏´‡∏±‡∏™‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô</div>
                    <button class="btn btn-primary" id="createRoomBtn">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á</button>
                </div>

                <div class="setup-card" id="joinCard">
                    <div class="setup-icon">üîó</div>
                    <div class="setup-title">‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏´‡πâ‡∏≠‡∏á</div>
                    <div class="setup-desc">‡πÉ‡∏™‡πà‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô</div>
                    <button class="btn btn-primary" id="showJoinBtn">‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°</button>
                </div>
            </div>

            <div id="joinSection" class="join-section hidden">
                <div class="join-title">‡πÉ‡∏™‡πà‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á 6 ‡∏´‡∏•‡∏±‡∏Å</div>
                <div class="input-group">
                    <input type="text" id="roomIdInput" placeholder="XXXXXX" maxlength="6">
                    <button class="btn btn-primary" id="joinRoomBtn">‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°</button>
                </div>
            </div>

            <div id="setupMessage"></div>
        </div>

        <!-- Transfer Screen -->
        <div id="transferScreen" class="hidden">
            <!-- Room Banner -->
            <div class="room-banner">
                <div class="room-label">‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á</div>
                <div class="room-code" id="currentRoomId">ABCDEF</div>
                <div class="room-hint">‡πÅ‡∏ä‡∏£‡πå‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°</div>
                <div id="securityBadge" class="security-badge pending">
                    <span>üîì</span>
                    <span id="securityText">‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™...</span>
                </div>
                <div id="roomTimer" class="room-timer hidden">
                    <span>‚è±Ô∏è</span>
                    <span id="timerText">‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÉ‡∏ô: --:--</span>
                </div>
            </div>

            <!-- Upload Zone -->
            <div class="upload-zone" id="uploadZone">
                <input type="file" id="fileInput"
                    accept="image/*,video/*,.mp4,.pdf,.doc,.docx,.xls,.xlsx,.txt,.zip,.rar">
                <div class="upload-icon">üìé</div>
                <div class="upload-title">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏≤‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</div>
                <div class="upload-subtitle">‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà (2GB+), E2EE, SHA-256 Verification, Resumable Transfer
                </div>
            </div>

            <!-- File Info -->
            <div id="fileCard" class="file-card hidden">
                <div class="file-header">
                    <div class="file-icon-large">üìÑ</div>
                    <div class="file-details">
                        <div class="file-name" id="fileName">document.pdf</div>
                        <div class="file-meta">
                            <div class="file-meta-item">
                                <span>üìä</span>
                                <span id="fileSize">2.5 MB</span>
                            </div>
                            <div class="file-meta-item">
                                <span>üè∑Ô∏è</span>
                                <span id="fileType">PDF Document</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Progress Section -->
            <div id="progressSection" class="progress-section hidden">
                <div class="progress-header">
                    <span class="progress-title">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå...</span>
                    <span class="progress-percentage" id="progressPercent">0%</span>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar-fill" id="progressFill" style="width: 0%"></div>
                </div>
                <div class="progress-info">
                    <span id="transferSpeed">‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß: 0 MB/s</span>
                    <span id="transferTime">‡πÄ‡∏´‡∏•‡∏∑‡∏≠: ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì...</span>
                </div>
            </div>

            <!-- Messages -->
            <div id="transferMessage"></div>

            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="btn btn-primary btn-full" id="sendFileBtn" disabled>
                    <span class="loading hidden" id="sendLoading">‚è≥</span>
                    <span id="sendText">‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå</span>
                </button>

                <!-- Control Buttons (Hidden by default) -->
                <button class="btn btn-secondary hidden" id="pauseBtn">‚è∏Ô∏è ‡∏û‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á (Pause)</button>
                <button class="btn btn-primary hidden" id="resumeBtn">‚ñ∂Ô∏è ‡∏™‡πà‡∏á‡∏ï‡πà‡∏≠ (Resume)</button>

                <button class="btn btn-secondary" id="clearFileBtn" disabled>‡∏•‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå</button>
                <button class="btn btn-secondary" id="leaveRoomBtn">‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏´‡πâ‡∏≠‡∏á</button>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const setupScreen = document.getElementById('setupScreen');
        const transferScreen = document.getElementById('transferScreen');
        const statusBadge = document.getElementById('statusBadge');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const showJoinBtn = document.getElementById('showJoinBtn');
        const joinSection = document.getElementById('joinSection');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const roomIdInput = document.getElementById('roomIdInput');
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const fileCard = document.getElementById('fileCard');
        const sendFileBtn = document.getElementById('sendFileBtn');
        const clearFileBtn = document.getElementById('clearFileBtn');
        const leaveRoomBtn = document.getElementById('leaveRoomBtn');
        const transferMessage = document.getElementById('transferMessage');
        const setupMessage = document.getElementById('setupMessage');
        const currentRoomIdDisplay = document.getElementById('currentRoomId');

        // Progress Elements
        const progressSection = document.getElementById('progressSection');
        const progressPercent = document.getElementById('progressPercent');
        const progressFill = document.getElementById('progressFill');
        const transferSpeed = document.getElementById('transferSpeed');
        const transferTime = document.getElementById('transferTime');

        // Settings Elements
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsModal = document.getElementById('settingsModal');
        const closeSettings = document.getElementById('closeSettings');
        const saveSettingsBtn = document.getElementById('saveSettingsBtn');
        const bandwidthSelect = document.getElementById('bandwidthSelect');
        const ttlSelect = document.getElementById('ttlSelect');
        const maxPeersSelect = document.getElementById('maxPeersSelect');

        // WebRTC & Signaling Variables
        let ws;
        let peerConnection;
        let dataChannel;
        let localPeerId;
        let roomId;
        let isInitiator = false;
        let currentRemotePeerId = null;

        const CHUNK_SIZE = 64 * 1024; // 64KB chunks for better performance with large files
        let currentFile = null;
        let receiveBuffer = []; // Fallback buffer
        let fileHandle = null; // for FileSystem Access API
        let writableStream = null;
        let receivedSize = 0;
        let incomingFileInfo = null;
        let startTime = 0;

        let bandwidthLimit = 0; // 0 = unlimited bytes/sec

        let isPaused = false;
        let isTransferring = false;
        let currentOffset = 0; // Track offset globally for resume

        // E2EE Variables
        let encryptionKey = null;
        let encryptionKeyExchanged = false;
        let fileHash = null; // Full file SHA-256 hash
        let receivedFileHash = null;

        // Room Timer Variables
        let roomExpiresAt = null;
        let roomTimerInterval = null;
        let roomTtlMinutes = 1440; // Default 24 hours

        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // --- Security Badge & Timer Functions ---
        function updateSecurityBadge(isSecure) {
            const badge = document.getElementById('securityBadge');
            const text = document.getElementById('securityText');
            if (isSecure) {
                badge.classList.remove('pending');
                badge.innerHTML = '<span>üîí</span><span>E2EE ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô (AES-256)</span>';
            } else {
                badge.classList.add('pending');
                badge.innerHTML = '<span>üîì</span><span>‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™...</span>';
            }
        }

        function startRoomTimer() {
            const timerDiv = document.getElementById('roomTimer');
            const timerText = document.getElementById('timerText');

            if (!roomExpiresAt) {
                timerDiv.classList.add('hidden');
                return;
            }

            timerDiv.classList.remove('hidden');

            if (roomTimerInterval) clearInterval(roomTimerInterval);

            roomTimerInterval = setInterval(() => {
                const now = Date.now();
                const remaining = roomExpiresAt - now;

                if (remaining <= 0) {
                    timerText.textContent = '‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÅ‡∏•‡πâ‡∏ß!';
                    timerDiv.className = 'room-timer critical';
                    clearInterval(roomTimerInterval);

                    // Auto-kick: ‡πÅ‡∏™‡∏î‡∏á alert ‡πÅ‡∏•‡∏∞‡πÄ‡∏î‡πâ‡∏á‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
                    alert('‚è±Ô∏è ‡∏´‡πâ‡∏≠‡∏á‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÅ‡∏•‡πâ‡∏ß! ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
                    window.location.reload();
                    return;
                }

                const hours = Math.floor(remaining / (1000 * 60 * 60));
                const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((remaining % (1000 * 60)) / 1000);

                if (hours > 0) {
                    timerText.textContent = `‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÉ‡∏ô: ${hours}‡∏ä‡∏°. ${minutes}‡∏ô‡∏≤‡∏ó‡∏µ`;
                } else if (minutes > 0) {
                    timerText.textContent = `‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÉ‡∏ô: ${minutes}‡∏ô‡∏≤‡∏ó‡∏µ ${seconds}‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ`;
                } else {
                    timerText.textContent = `‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÉ‡∏ô: ${seconds}‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ`;
                }

                // Color based on remaining time
                if (remaining < 60000) { // Less than 1 minute
                    timerDiv.className = 'room-timer critical';
                } else if (remaining < 300000) { // Less than 5 minutes
                    timerDiv.className = 'room-timer warning';
                } else {
                    timerDiv.className = 'room-timer';
                }
            }, 1000);
        }

        // --- Settings Logic ---
        settingsBtn.onclick = () => settingsModal.classList.remove('hidden');
        closeSettings.onclick = () => settingsModal.classList.add('hidden');
        saveSettingsBtn.onclick = () => {
            bandwidthLimit = parseInt(bandwidthSelect.value) * 1024 * 1024; // Convert MB to bytes
            settingsModal.classList.add('hidden');
        };
        window.onclick = (event) => {
            if (event.target == settingsModal) {
                settingsModal.classList.add('hidden');
            }
        };

        // --- UI Interactions ---

        function generateRoomId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        createRoomBtn.onclick = () => {
            initWebSocket();
            roomId = generateRoomId();
            isInitiator = true;
            setupMessage.innerText = 'Connecting to signaling server...';
        };

        showJoinBtn.onclick = () => {
            document.querySelector('.setup-grid').classList.add('hidden');
            joinSection.classList.remove('hidden');
        };

        joinRoomBtn.onclick = () => {
            const inputId = roomIdInput.value.trim().toUpperCase();
            if (inputId.length !== 6) {
                showSetupError('Please enter a valid 6-digit Room ID');
                return;
            }
            roomId = inputId;
            isInitiator = false;
            initWebSocket();
            setupMessage.innerText = 'Connecting to signaling server...';
        };

        function showSetupError(msg) {
            setupMessage.innerHTML = `<div class="message message-error">${msg}</div>`;
        }

        function updateStatus(state) {
            statusBadge.className = 'status-badge ' + state;
            let text = '';
            switch (state) {
                case 'status-waiting': text = 'Waiting for peer'; break;
                case 'status-connecting': text = 'Connecting...'; break;
                case 'status-connected': text = 'Connected'; break;
                case 'status-transferring': text = 'Transferring...'; break;
            }
            statusBadge.innerHTML = `<span class="status-dot"></span><span>${text}</span>`;
        }

        function showTransferScreen() {
            setupScreen.classList.add('hidden');
            transferScreen.classList.remove('hidden');
            currentRoomIdDisplay.textContent = roomId;
        }

        // --- File Handling ---

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadZone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            uploadZone.addEventListener(eventName, () => uploadZone.classList.add('dragover'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            uploadZone.addEventListener(eventName, () => uploadZone.classList.remove('dragover'), false);
        });

        uploadZone.addEventListener('drop', handleDrop, false);
        uploadZone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelect);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            handleFiles(files);
        }

        function handleFiles(files) {
            if (files.length > 0) {
                selectFile(files[0]);
            }
        }

        function selectFile(file) {
            currentFile = file;
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileSize').textContent = formatBytes(file.size);
            document.getElementById('fileType').textContent = file.type || 'Unknown';

            fileCard.classList.remove('hidden');
            sendFileBtn.disabled = false;
            clearFileBtn.disabled = false;
            uploadZone.style.display = 'none';
        }

        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        clearFileBtn.onclick = resetFileSelection;

        function resetFileSelection() {
            currentFile = null;
            fileCard.classList.add('hidden');
            sendFileBtn.disabled = true;
            clearFileBtn.disabled = true;
            fileInput.value = '';
            uploadZone.style.display = 'block';
            progressSection.classList.add('hidden');
            transferMessage.innerHTML = '';
        }

        leaveRoomBtn.onclick = () => {
            window.location.reload();
        };

        sendFileBtn.onclick = () => {
            if (!currentFile || !dataChannel || dataChannel.readyState !== 'open') return;
            sendFile();
        };

        // --- Signaling & WebRTC ---

        function initWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

            ws.onopen = () => {
                const action = isInitiator ? 'create_room' : 'join_room';
                const payload = {
                    action: action,
                    room_id: roomId
                };

                if (isInitiator) {
                    roomTtlMinutes = parseInt(ttlSelect.value);
                    payload.config = {
                        ttl: roomTtlMinutes,
                        max_peers: parseInt(maxPeersSelect.value)
                    };
                }

                ws.send(JSON.stringify(payload));
            };

            ws.onmessage = async (event) => {
                const msg = JSON.parse(event.data);

                switch (msg.type) {
                    case 'room_created':
                        localPeerId = msg.peer_id;
                        roomId = msg.room_id;
                        // Set room expiration for timer
                        roomExpiresAt = Date.now() + (roomTtlMinutes * 60 * 1000);
                        showTransferScreen();
                        updateStatus('status-waiting');
                        startRoomTimer();
                        break;

                    case 'room_joined':
                        localPeerId = msg.peer_id;
                        // ‡∏£‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡∏à‡∏≤‡∏Å server ‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏° timer ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°
                        if (msg.expires_at && msg.expires_at > 0) {
                            roomExpiresAt = msg.expires_at * 1000; // ‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å seconds ‡πÄ‡∏õ‡πá‡∏ô milliseconds
                        }
                        showTransferScreen();
                        updateStatus('status-connecting');
                        startRoomTimer(); // ‡πÄ‡∏£‡∏¥‡πà‡∏° timer ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏î‡πâ‡∏ß‡∏¢
                        break;

                    case 'peer_joined':
                        currentRemotePeerId = msg.peer_id;
                        updateStatus('status-connecting');
                        startWebRTC(true);
                        break;

                    case 'signal':
                        if (!currentRemotePeerId) currentRemotePeerId = msg.sender_peer_id;
                        if (!peerConnection) startWebRTC(false);
                        handleSignal(msg.data);
                        break;

                    case 'peer_left':
                        if (isTransferring || receivedSize > 0) {
                            transferMessage.innerHTML = `<div class="message message-error">Peer disconnected. Transfer paused at ${formatBytes(receivedSize)}. Waiting for reconnection to resume...</div>`;
                            isPaused = true;
                            isTransferring = false;
                            pauseBtn.classList.add('hidden');
                            resumeBtn.classList.remove('hidden');
                        } else {
                            transferMessage.innerHTML = `<div class="message message-error">Peer disconnected. Waiting for reconnection...</div>`;
                        }
                        updateStatus('status-waiting');
                        if (peerConnection) {
                            peerConnection.close();
                            peerConnection = null;
                        }
                        dataChannel = null;
                        // Will reconnect when peer rejoins
                        break;

                    case 'error':
                        if (msg.message === 'Room expired') {
                            alert('Session Expired: The room has timed out.');
                            window.location.reload(); // Redirect/Reset to home
                        } else {
                            showSetupError(msg.message);
                        }
                        break;
                }
            };

            ws.onclose = () => {
                console.log('WebSocket closed. Reconnecting...');
                updateStatus('status-waiting');
                setTimeout(initWebSocket, 3000); // Retry connection
            };
        }

        function startWebRTC(isOfferer) {
            peerConnection = new RTCPeerConnection(rtcConfig);

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({
                        action: 'signal',
                        target_peer_id: currentRemotePeerId,
                        data: { type: 'candidate', candidate: event.candidate }
                    }));
                }
            };

            peerConnection.onconnectionstatechange = () => {
                if (peerConnection.connectionState === 'connected') {
                    updateStatus('status-connected');
                } else if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                    updateStatus('status-waiting');
                }
            };

            if (isOfferer) {
                dataChannel = peerConnection.createDataChannel("fileTransfer");
                setupDataChannel(dataChannel);

                peerConnection.createOffer().then(offer => {
                    peerConnection.setLocalDescription(offer);
                    ws.send(JSON.stringify({
                        action: 'signal',
                        target_peer_id: currentRemotePeerId,
                        data: { type: 'offer', sdp: offer }
                    }));
                });
            } else {
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannel(dataChannel);
                };
            }
        }

        async function handleSignal(data) {
            if (data.type === 'offer') {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                ws.send(JSON.stringify({
                    action: 'signal',
                    target_peer_id: currentRemotePeerId,
                    data: { type: 'answer', sdp: answer }
                }));
            } else if (data.type === 'answer') {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
            } else if (data.type === 'candidate') {
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
        }

        function setupDataChannel(channel) {
            channel.onopen = async () => {
                updateStatus('status-connected');

                // Exchange encryption keys for E2EE
                if (!encryptionKeyExchanged) {
                    if (isInitiator) {
                        // Generate and send key
                        encryptionKey = await generateEncryptionKey();
                        const keyData = await exportKey(encryptionKey);
                        const keyArray = new Uint8Array(keyData);

                        // Send key (first 4 bytes = length, then key data)
                        const lengthBytes = new Uint8Array(4);
                        const view = new DataView(lengthBytes.buffer);
                        view.setUint32(0, keyArray.length, false);

                        // Send as binary
                        channel.send(lengthBytes.buffer);
                        // Wait a bit to ensure first message is processed
                        await new Promise(r => setTimeout(r, 10));
                        channel.send(keyArray.buffer);

                        // Mark as exchanged (initiator has the key)
                        encryptionKeyExchanged = true;
                        updateSecurityBadge(true);
                    } else {
                        // Wait for key from initiator
                        // Key exchange will happen in handleDataChannelMessage
                    }
                }
            };

            channel.onmessage = (event) => {
                messageQueue.push(event);
                processMessageQueue();
            };
        }

        // --- Message Queue for Sequential Processing ---
        const messageQueue = [];
        let isProcessingQueue = false;

        async function processMessageQueue() {
            if (isProcessingQueue) return;
            isProcessingQueue = true;

            while (messageQueue.length > 0) {
                const event = messageQueue.shift();
                try {
                    await processDataChannelMessage(event);
                } catch (error) {
                    console.error("Error processing message from queue:", error);
                }
            }

            isProcessingQueue = false;
        }

        // --- Encryption & Security Functions ---

        // Generate encryption key for E2EE
        async function generateEncryptionKey() {
            return await crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }

        // Export key for exchange
        async function exportKey(key) {
            return await crypto.subtle.exportKey('raw', key);
        }

        // Import key from exchange
        async function importKey(keyData) {
            return await crypto.subtle.importKey(
                'raw',
                keyData,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }

        // Encrypt data with AES-GCM
        async function encryptData(data, key) {
            const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV for GCM
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );
            // Combine IV + encrypted data
            const result = new Uint8Array(iv.length + encrypted.byteLength);
            result.set(iv, 0);
            result.set(new Uint8Array(encrypted), iv.length);
            return result;
        }

        // Decrypt data with AES-GCM
        async function decryptData(encryptedData, key) {
            const iv = encryptedData.slice(0, 12);
            const data = encryptedData.slice(12);
            return await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );
        }

        // Encrypt metadata (JSON string)
        async function encryptMetadata(metadata, key) {
            const metadataStr = JSON.stringify(metadata);
            const metadataBytes = new TextEncoder().encode(metadataStr);
            return await encryptData(metadataBytes, key);
        }

        // Decrypt metadata
        async function decryptMetadata(encryptedMetadata, key) {
            const decrypted = await decryptData(encryptedMetadata, key);
            const metadataStr = new TextDecoder().decode(decrypted);
            return JSON.parse(metadataStr);
        }

        // --- Integrity Helper functions ---
        async function computeHash(data) {
            return await crypto.subtle.digest('SHA-256', data);
        }

        // Compute full file hash (for large files, use streaming)
        async function computeFileHash(file, onProgress) {
            // Streaming SHA-256 implementation for large files
            // Uses incremental hashing to avoid loading entire file into memory
            const chunkSize = 2 * 1024 * 1024; // 2MB chunks for hashing
            const totalSize = file.size;
            let offset = 0;

            // Initialize SHA-256 state manually using SubtleCrypto workaround
            // We'll collect chunk hashes and compute final hash differently
            // Actually, we need a true streaming hash - let's use a different approach

            // For files under 500MB, use direct approach
            if (file.size < 500 * 1024 * 1024) {
                const buffer = await file.arrayBuffer();
                const hash = await crypto.subtle.digest('SHA-256', buffer);
                return new Uint8Array(hash);
            }

            // For large files, use chunked reading with a streaming hasher
            // We'll use a simple approach: read chunks and update progress
            // but compute hash at the end using ReadableStream

            // Use ReadableStream approach for large files
            const reader = file.stream().getReader();
            const chunks = [];
            let readBytes = 0;

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                chunks.push(value);
                readBytes += value.length;

                if (onProgress) {
                    onProgress(Math.round((readBytes / totalSize) * 100));
                }

                // Process in batches to keep memory manageable
                if (chunks.length >= 50) { // ~50 chunks = ~3MB typically
                    await new Promise(r => setTimeout(r, 0)); // Yield to UI
                }
            }

            // Combine chunks for final hash
            const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
            const combined = new Uint8Array(totalLength);
            let position = 0;
            for (const chunk of chunks) {
                combined.set(chunk, position);
                position += chunk.length;
            }

            const hash = await crypto.subtle.digest('SHA-256', combined);
            return new Uint8Array(hash);
        }

        async function verifyAndSplit(buffer) {
            if (buffer.byteLength < 32) throw new Error("Data too short for hash");

            const receivedHash = new Uint8Array(buffer.slice(0, 32));
            const chunkData = buffer.slice(32);

            const computedHashBuffer = await computeHash(chunkData);
            const computedHash = new Uint8Array(computedHashBuffer);

            for (let i = 0; i < 32; i++) {
                if (receivedHash[i] !== computedHash[i]) {
                    throw new Error("Integrity Check Failed");
                }
            }

            return chunkData;
        }

        // Key exchange state
        let keyExchangeState = { waitingForLength: true, keyLength: 0, keyBuffer: null, keyBytesReceived: 0 };

        async function processDataChannelMessage(event) {
            const data = event.data;

            // Handle key exchange first (only for receiver)
            if (!encryptionKeyExchanged && !isInitiator) {
                if (data instanceof ArrayBuffer || data instanceof Blob) {
                    const arrayBuffer = data instanceof Blob ? await data.arrayBuffer() : data;

                    if (keyExchangeState.waitingForLength) {
                        if (arrayBuffer.byteLength >= 4) {
                            const view = new DataView(arrayBuffer);
                            keyExchangeState.keyLength = view.getUint32(0, false);
                            keyExchangeState.keyBuffer = new Uint8Array(keyExchangeState.keyLength);
                            keyExchangeState.keyBytesReceived = 0;
                            keyExchangeState.waitingForLength = false;

                            // If there's more data in this message
                            if (arrayBuffer.byteLength > 4) {
                                const keyData = new Uint8Array(arrayBuffer.slice(4));
                                keyExchangeState.keyBuffer.set(keyData, 0);
                                keyExchangeState.keyBytesReceived = keyData.length;

                                if (keyExchangeState.keyBytesReceived >= keyExchangeState.keyLength) {
                                    encryptionKey = await importKey(keyExchangeState.keyBuffer);
                                    encryptionKeyExchanged = true;
                                    updateSecurityBadge(true);
                                    keyExchangeState = { waitingForLength: true, keyLength: 0, keyBuffer: null, keyBytesReceived: 0 };
                                }
                            }
                        }
                        return;
                    } else {
                        // Receiving key data
                        const keyData = new Uint8Array(arrayBuffer);
                        const remaining = keyExchangeState.keyLength - keyExchangeState.keyBytesReceived;
                        const toCopy = Math.min(remaining, keyData.length);

                        keyExchangeState.keyBuffer.set(keyData.slice(0, toCopy), keyExchangeState.keyBytesReceived);
                        keyExchangeState.keyBytesReceived += toCopy;

                        if (keyExchangeState.keyBytesReceived >= keyExchangeState.keyLength) {
                            encryptionKey = await importKey(keyExchangeState.keyBuffer);
                            encryptionKeyExchanged = true;
                            updateSecurityBadge(true);
                            keyExchangeState = { waitingForLength: true, keyLength: 0, keyBuffer: null, keyBytesReceived: 0 };
                        }
                        return;
                    }
                }
            }

            // If key not exchanged yet, wait (for both initiator and receiver)
            if (!encryptionKeyExchanged) {
                return;
            }

            if (typeof data === 'string') {
                // Encrypted metadata - decrypt first
                try {
                    let msg;
                    if (encryptionKeyExchanged) {
                        const encryptedBytes = Uint8Array.from(atob(data), c => c.charCodeAt(0));
                        const decrypted = await decryptMetadata(encryptedBytes, encryptionKey);
                        msg = decrypted;
                    } else {
                        msg = JSON.parse(data);
                    }

                    if (msg.type === 'file-start') {
                        // Check if we're resuming or starting fresh
                        const isResume = msg.resumeSupported && receivedSize > 0 && fileHandle;

                        if (!isResume) {
                            incomingFileInfo = msg;
                            // receivedFileHash = msg.fileHash ? new Uint8Array(Object.values(msg.fileHash)) : null; // Removed
                            receivedSize = 0;
                            startTime = Date.now();
                        } else {
                            // Update file info but keep receivedSize
                            incomingFileInfo = msg;
                            // receivedFileHash = msg.fileHash ? new Uint8Array(Object.values(msg.fileHash)) : null; // Removed
                        }

                        updateStatus('status-transferring');
                        progressSection.classList.remove('hidden');
                        const percent = Math.round((receivedSize / msg.size) * 100);
                        progressFill.style.width = percent + '%';
                        progressPercent.textContent = percent + '%';

                        document.getElementById('fileName').textContent = msg.name;
                        document.getElementById('fileSize').textContent = formatBytes(msg.size);
                        document.getElementById('fileType').textContent = msg.fileType || 'Unknown';
                        fileCard.classList.remove('hidden');
                        uploadZone.style.display = 'none';

                        // Try FileSystem Access API for large files (only if not resuming)
                        if (!isResume) {
                            if ('showSaveFilePicker' in window) {
                                try {
                                    fileHandle = await window.showSaveFilePicker({
                                        suggestedName: msg.name
                                    });
                                    writableStream = await fileHandle.createWritable();
                                    receiveBuffer = null; // Don't use memory buffer
                                } catch (err) {
                                    console.log('User cancelled or API fail, fallback to memory', err);
                                    // Safety Check for Fallback
                                    if (msg.size > 2 * 1024 * 1024 * 1024) { // 2GB limit for memory
                                        alert("Warning: You are receiving a large file (>2GB) without File System Access. Your browser might crash due to memory limits.");
                                    }
                                    receiveBuffer = [];
                                }
                            } else {
                                // Safety Check for Fallback
                                if (msg.size > 2 * 1024 * 1024 * 1024) { // 2GB limit for memory
                                    alert("Warning: You are receiving a large file (>2GB) without File System Access. Your browser might crash due to memory limits.");
                                }
                                receiveBuffer = [];
                            }
                        } else {
                            // Resuming - reopen writable stream if using FileSystem API
                            if (fileHandle && !writableStream) {
                                writableStream = await fileHandle.createWritable({ keepExistingData: true });
                            }
                        }

                        // Send resume request if needed
                        if (msg.resumeSupported && receivedSize > 0) {
                            const resumeRequest = { type: 'resume-request', offset: receivedSize };
                            if (encryptionKeyExchanged) {
                                const encrypted = await encryptMetadata(resumeRequest, encryptionKey);
                                const base64 = btoa(String.fromCharCode(...encrypted));
                                dataChannel.send(base64);
                            } else {
                                dataChannel.send(JSON.stringify(resumeRequest));
                            }
                        }

                    } else if (msg.type === 'file-end') {
                        // File transfer complete!
                        // We've already verified each chunk's integrity during transfer (per-chunk SHA-256 + AES-GCM)
                        // So no need to read back the entire file into memory (which would fail for 2GB+ files)

                        if (writableStream) {
                            // Using FileSystem Access API - just close the stream
                            await writableStream.close();
                            writableStream = null;
                            // File is already saved to disk by the user's chosen location
                        } else if (receiveBuffer && receiveBuffer.length > 0) {
                            // Fallback: Using in-memory buffer - create blob and trigger download
                            const blob = new Blob(receiveBuffer, { type: incomingFileInfo.fileType || 'application/octet-stream' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = incomingFileInfo.name;
                            a.click();
                            // Delay revoke to ensure download starts
                            setTimeout(() => URL.revokeObjectURL(url), 1000);
                            // Clear buffer to free memory
                            receiveBuffer = [];
                        }

                        // Reset file handle for next transfer
                        fileHandle = null;

                        updateStatus('status-connected');
                        transferMessage.innerHTML = `<div class="message message-success">File received and verified: ${incomingFileInfo.name}</div>`;

                        setTimeout(() => {
                            progressSection.classList.add('hidden');
                            transferMessage.innerHTML = '';
                            resetFileSelection();
                        }, 3000);
                    } else if (msg.type === 'resume-request') {
                        // Receiver wants to resume from a specific offset
                        if (isTransferring) {
                            // Pause current transfer
                            isPaused = true;
                            pauseBtn.classList.add('hidden');
                            resumeBtn.classList.remove('hidden');
                        }
                        // Update offset and resume
                        currentOffset = msg.offset;
                        isPaused = false;
                        isTransferring = false;
                        transferMessage.innerHTML = `<div class="message message-info">Resuming transfer from ${formatBytes(msg.offset)}...</div>`;
                        // Resume sending from the requested offset
                        setTimeout(() => {
                            sendFile(msg.offset);
                        }, 100);
                    } else if (msg.type === 'resume') {
                        // Sender is resuming, update our offset tracking
                        if (msg.offset !== undefined) {
                            // This is just informational for the receiver
                            console.log("Sender resuming from offset:", msg.offset);
                        }
                    }
                } catch (e) {
                    console.error("Decryption/Parse error:", e);
                    transferMessage.innerHTML = `<div class="message message-error">Error processing message: ${e.message}</div>`;
                }
            } else {
                // Binary Data: [Hash (32 bytes)][Encrypted Chunk Data]
                try {
                    // Decrypt if encryption is enabled
                    let chunkData;
                    if (encryptionKeyExchanged) {
                        const encryptedChunk = new Uint8Array(data);
                        // First verify chunk hash
                        const receivedHash = new Uint8Array(encryptedChunk.slice(0, 32));
                        const encryptedData = encryptedChunk.slice(32);

                        // Decrypt
                        const decryptedBuffer = await decryptData(encryptedData, encryptionKey);

                        // Verify decrypted chunk hash
                        const computedHashBuffer = await computeHash(decryptedBuffer);
                        const computedHash = new Uint8Array(computedHashBuffer);

                        for (let i = 0; i < 32; i++) {
                            if (receivedHash[i] !== computedHash[i]) {
                                throw new Error("Chunk Integrity Check Failed");
                            }
                        }

                        chunkData = decryptedBuffer;
                    } else {
                        chunkData = await verifyAndSplit(data);
                    }

                    const chunkSize = chunkData.byteLength;
                    receivedSize += chunkSize;

                    if (writableStream) {
                        await writableStream.write(chunkData);
                    } else {
                        receiveBuffer.push(chunkData);
                    }

                    if (incomingFileInfo) {
                        const percent = Math.round((receivedSize / incomingFileInfo.size) * 100);
                        progressFill.style.width = percent + '%';
                        progressPercent.textContent = percent + '%';

                        const now = Date.now();
                        const durationInSeconds = (now - startTime) / 1000;
                        if (durationInSeconds > 0) {
                            const speed = (receivedSize / 1024 / 1024) / durationInSeconds;
                            transferSpeed.textContent = `Speed: ${speed.toFixed(2)} MB/s`;

                            const remaining = incomingFileInfo.size - receivedSize;
                            const eta = remaining / (speed * 1024 * 1024);
                            if (eta > 0 && eta < 86400) {
                                const hours = Math.floor(eta / 3600);
                                const minutes = Math.floor((eta % 3600) / 60);
                                const seconds = Math.floor(eta % 60);
                                if (hours > 0) {
                                    transferTime.textContent = `‡πÄ‡∏´‡∏•‡∏∑‡∏≠: ${hours}‡∏ä‡∏°. ${minutes}‡∏ô‡∏≤‡∏ó‡∏µ`;
                                } else if (minutes > 0) {
                                    transferTime.textContent = `‡πÄ‡∏´‡∏•‡∏∑‡∏≠: ${minutes}‡∏ô‡∏≤‡∏ó‡∏µ ${seconds}‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ`;
                                } else {
                                    transferTime.textContent = `‡πÄ‡∏´‡∏•‡∏∑‡∏≠: ${seconds}‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ`;
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error("Integrity/Decryption Error:", e);
                    transferMessage.innerHTML = `<div class="message message-error">Integrity/Decryption Verification Failed! ${e.message}</div>`;
                    if (writableStream) await writableStream.abort();
                    isPaused = true;
                    isTransferring = false;
                    pauseBtn.classList.add('hidden');
                    resumeBtn.classList.remove('hidden');
                }
            }
        }

        // --- Controls ---
        const pauseBtn = document.getElementById('pauseBtn');
        const resumeBtn = document.getElementById('resumeBtn');

        pauseBtn.onclick = () => {
            isPaused = true;
            pauseBtn.classList.add('hidden');
            resumeBtn.classList.remove('hidden');
            updateStatus('status-waiting');
            transferMessage.innerHTML = `<div class="message message-info">Transfer Paused</div>`;
        };

        resumeBtn.onclick = () => {
            isPaused = false;
            resumeBtn.classList.add('hidden');
            pauseBtn.classList.remove('hidden');
            updateStatus('status-transferring');
            transferMessage.innerHTML = '';
            // If stopped due to error/pause state, we resume logic
            if (!isTransferring) {
                sendFile(currentOffset);
            }
        };

        async function sendFile(startOffset = 0) {
            if (!currentFile || !dataChannel) return;

            // Wait for encryption key exchange if not done
            if (!encryptionKeyExchanged) {
                await new Promise(resolve => {
                    const checkKey = setInterval(() => {
                        if (encryptionKeyExchanged) {
                            clearInterval(checkKey);
                            resolve();
                        }
                    }, 100);
                });
            }

            isTransferring = true;
            isPaused = false;
            updateStatus('status-transferring');
            progressSection.classList.remove('hidden');
            transferMessage.innerHTML = '';

            // Show Controls
            sendFileBtn.classList.add('hidden');
            pauseBtn.classList.remove('hidden');
            resumeBtn.classList.add('hidden');

            // Compute full file hash if starting from beginning
            if (startOffset === 0) {
                // Prepare encrypted metadata
                const metadata = {
                    type: 'file-start',
                    name: currentFile.name,
                    size: currentFile.size,
                    fileType: currentFile.type,
                    resumeSupported: true
                };

                // Encrypt and send metadata
                if (encryptionKeyExchanged) {
                    const encryptedMetadata = await encryptMetadata(metadata, encryptionKey);
                    const base64 = btoa(String.fromCharCode(...encryptedMetadata));
                    dataChannel.send(base64);
                } else {
                    dataChannel.send(JSON.stringify(metadata));
                }

                currentOffset = 0;
                startTime = Date.now();
            } else {
                console.log("Resuming from " + startOffset);
                // Send resume notification
                const resumeMsg = { type: 'resume', offset: startOffset };
                if (encryptionKeyExchanged) {
                    const encrypted = await encryptMetadata(resumeMsg, encryptionKey);
                    const base64 = btoa(String.fromCharCode(...encrypted));
                    dataChannel.send(base64);
                } else {
                    dataChannel.send(JSON.stringify(resumeMsg));
                }
                currentOffset = startOffset;
            }

            let lastThrottleTime = Date.now();
            let bytesSentThisSecond = 0;
            const throttleResetInterval = 1000;

            // Process and send a single chunk
            async function processAndSendChunk(chunkData) {
                // Check Pause State
                while (isPaused) {
                    await new Promise(r => setTimeout(r, 500));
                }

                // Check Connection State
                if (dataChannel.readyState !== 'open') {
                    console.log("Channel not open, pausing...");
                    isPaused = true;
                    isTransferring = false;
                    pauseBtn.classList.add('hidden');
                    resumeBtn.classList.remove('hidden');
                    transferMessage.innerHTML = `<div class="message message-error">Connection Lost. Click Resume to retry from offset ${currentOffset}.</div>`;
                    return false;
                }

                const now = Date.now();

                // Bandwidth Throttling
                if (bandwidthLimit > 0) {
                    if (now - lastThrottleTime >= throttleResetInterval) {
                        bytesSentThisSecond = 0;
                        lastThrottleTime = now;
                    }

                    if (bytesSentThisSecond + chunkData.byteLength > bandwidthLimit) {
                        const waitTime = throttleResetInterval - (now - lastThrottleTime);
                        if (waitTime > 0) {
                            await new Promise(r => setTimeout(r, waitTime));
                            bytesSentThisSecond = 0;
                            lastThrottleTime = Date.now();
                        }
                    }

                    bytesSentThisSecond += chunkData.byteLength;
                }

                // Compute chunk hash
                const hashBuffer = await computeHash(chunkData);
                const hashArray = new Uint8Array(hashBuffer);

                // Encrypt chunk if encryption is enabled
                let dataToSend;
                if (encryptionKeyExchanged) {
                    const encryptedChunk = await encryptData(chunkData, encryptionKey);
                    dataToSend = new Uint8Array(hashArray.length + encryptedChunk.length);
                    dataToSend.set(hashArray, 0);
                    dataToSend.set(encryptedChunk, hashArray.length);
                } else {
                    const chunkArray = new Uint8Array(chunkData);
                    dataToSend = new Uint8Array(hashArray.length + chunkArray.length);
                    dataToSend.set(hashArray, 0);
                    dataToSend.set(chunkArray, hashArray.length);
                }

                // Flow Control (Backpressure)
                const maxBufferSize = 16 * 1024 * 1024; // 16MB buffer
                const minBufferSize = 4 * 1024 * 1024; // 4MB threshold

                if (dataChannel.bufferedAmount > maxBufferSize) {
                    await new Promise(resolve => {
                        const checkBuffer = setInterval(() => {
                            if (dataChannel.bufferedAmount < minBufferSize) {
                                clearInterval(checkBuffer);
                                resolve();
                            }
                        }, 50);
                    });
                }

                try {
                    dataChannel.send(dataToSend);
                } catch (err) {
                    console.error('Send error:', err);

                    if (err.message && (err.message.includes('queue is full') || err.name === 'OperationError')) {
                        transferMessage.innerHTML = `<div class="message message-warning">Send buffer full. Auto-retrying in 1s... (Offset: ${currentOffset})</div>`;
                        return 'retry';
                    }

                    isPaused = true;
                    isTransferring = false;
                    pauseBtn.classList.add('hidden');
                    resumeBtn.classList.remove('hidden');
                    transferMessage.innerHTML = `<div class="message message-error">Send Error: ${err.message}. Click Resume to retry from offset ${currentOffset}.</div>`;
                    return false;
                }

                currentOffset += chunkData.byteLength;

                // Update Progress
                const percent = Math.round((currentOffset / currentFile.size) * 100);
                progressFill.style.width = percent + '%';
                progressPercent.textContent = percent + '%';

                const duration = (Date.now() - startTime) / 1000;
                if (duration > 0) {
                    const speed = (currentOffset / 1024 / 1024) / duration;
                    transferSpeed.textContent = `Speed: ${speed.toFixed(2)} MB/s`;

                    const remaining = currentFile.size - currentOffset;
                    const eta = remaining / (speed * 1024 * 1024);
                    if (eta > 0 && eta < 86400) {
                        const hours = Math.floor(eta / 3600);
                        const minutes = Math.floor((eta % 3600) / 60);
                        const seconds = Math.floor(eta % 60);
                        if (hours > 0) {
                            transferTime.textContent = `‡πÄ‡∏´‡∏•‡∏∑‡∏≠: ${hours}‡∏ä‡∏°. ${minutes}‡∏ô‡∏≤‡∏ó‡∏µ`;
                        } else if (minutes > 0) {
                            transferTime.textContent = `‡πÄ‡∏´‡∏•‡∏∑‡∏≠: ${minutes}‡∏ô‡∏≤‡∏ó‡∏µ ${seconds}‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ`;
                        } else {
                            transferTime.textContent = `‡πÄ‡∏´‡∏•‡∏∑‡∏≠: ${seconds}‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ`;
                        }
                    }
                }

                return true;
            }

            // Use FileReader with slice - but with better error handling
            // This approach works better than stream() for resume support
            const reader = new FileReader();
            let readOffset = startOffset;
            let retryCount = 0;
            const maxRetries = 3;

            function readNextChunk() {
                if (isPaused || !isTransferring) return;

                try {
                    const end = Math.min(readOffset + CHUNK_SIZE, currentFile.size);
                    const slice = currentFile.slice(readOffset, end);
                    reader.readAsArrayBuffer(slice);
                } catch (err) {
                    console.error('File slice error:', err);
                    if (retryCount < maxRetries) {
                        retryCount++;
                        transferMessage.innerHTML = `<div class="message message-warning">File read error, retrying... (${retryCount}/${maxRetries})</div>`;
                        setTimeout(readNextChunk, 1000);
                    } else {
                        isPaused = true;
                        isTransferring = false;
                        pauseBtn.classList.add('hidden');
                        resumeBtn.classList.remove('hidden');
                        transferMessage.innerHTML = `<div class="message message-error">File Read Error: ${err.message}. Click Resume to retry.</div>`;
                    }
                }
            }

            reader.onload = async (e) => {
                retryCount = 0; // Reset retry count on successful read
                const chunk = e.target.result;

                const result = await processAndSendChunk(chunk);

                if (result === 'retry') {
                    // Wait and retry sending from current offset
                    setTimeout(() => {
                        if (!isPaused) {
                            sendFile(currentOffset);
                        }
                    }, 1000);
                    return;
                }

                if (result === false) {
                    return; // Error occurred, already handled
                }

                readOffset = currentOffset;

                if (currentOffset < currentFile.size) {
                    // Small delay to prevent UI freeze
                    setTimeout(readNextChunk, 0);
                } else {
                    // Transfer complete - send file-end
                    const endMsg = { type: 'file-end' };
                    if (encryptionKeyExchanged) {
                        const encrypted = await encryptMetadata(endMsg, encryptionKey);
                        const base64 = btoa(String.fromCharCode(...encrypted));
                        dataChannel.send(base64);
                    } else {
                        dataChannel.send(JSON.stringify(endMsg));
                    }

                    updateStatus('status-connected');
                    transferMessage.innerHTML = `<div class="message message-success">File sent successfully! SHA-256 verified.</div>`;

                    isTransferring = false;
                    sendFileBtn.classList.remove('hidden');
                    pauseBtn.classList.add('hidden');

                    setTimeout(() => {
                        progressSection.classList.add('hidden');
                        transferMessage.innerHTML = '';
                    }, 3000);
                }
            };

            reader.onerror = (err) => {
                console.error('FileReader error:', err);
                if (retryCount < maxRetries) {
                    retryCount++;
                    transferMessage.innerHTML = `<div class="message message-warning">File read error, retrying... (${retryCount}/${maxRetries})</div>`;
                    setTimeout(readNextChunk, 1000);
                } else {
                    isPaused = true;
                    isTransferring = false;
                    pauseBtn.classList.add('hidden');
                    resumeBtn.classList.remove('hidden');
                    transferMessage.innerHTML = `<div class="message message-error">File Read Error. Click Resume to retry from offset ${currentOffset}.</div>`;
                }
            };

            // Start reading
            readNextChunk();
        }
    </script>
</body>

</html>